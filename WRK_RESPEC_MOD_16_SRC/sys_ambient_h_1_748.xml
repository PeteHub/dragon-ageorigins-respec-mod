<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Resource ModuleID="1" OwnerModuleID="1" ResRefID="748" Folder="\_Systems\_Includes\" ResRefName="sys_ambient_h" IsCore="1" OwnerIsCore="1" Type="3" State="0" ObjectName="" Relationship="" ResType="nss" URI="bw-db://.\BWDATOOLSET/bw_dragonage_content\sys_ambient_h.nss?moduleid=1&amp;resrefid=748" Requested="0">
	<Agent type="empty">
		<ResRefName>sys_ambient_h</ResRefName>
		<LocalCopy type="bool">False</LocalCopy>
		<text>////////////////////////////////////////////////////////////////////////////////
//  sys_ambient_h
//  Copyright Â© 2007 BioWare Corp.
/////////////////////////////////////////////////////////////////////////////
/*
    Implementation of ambient behaviour system.

    By default, ambient behaviour begins when a creature sees the player and
    ceases a short time after the party leaves the creature's sight. Ambient
    behaviour alternates between a movement phase and an animation phase. In a
    movement phase, the creature (optionally) moves to a new destination object.
    In an animation phase, the creature (optionally) performs one or more
    animations either in sequence or at random. Exact behaviour is controlled by
    local variables on the creature template (see below).

    The actions comprising the animation pattern used in an animation phase are
    listed in ambient_ai.xls. Each row defines an animation pattern consisting
    of up to nine actions. Each action is composed of an animation (left of the
    decimal) and loop count (right of decimal). For example, 619.05 will play a
    sleeping animation for 5 loops and 619.99 will loop infinitely.
    Non-looping animations require no loop count (e.g. 808.00 = point right).

    The only functions safe to call outside sys_ambient_h or creature_core are:
        - Ambient_Start()
        - Ambient_StartTeam()
        - Ambient_StartTag()
        - Ambient_Stop()
        - Ambient_OverrideBehaviour()
        - Ambient_RestoreBehaviour()

    Local variables stored on the creature used by this script:
        AMBIENT_SYSTEM_STATE = State bitmask of AMBIENT_SYSTEM_XXX values
        AMBIENT_MOVE_PATTERN = Ambient movement pattern constant AMBIENT_MOVE_XXX (0-7)
        AMBIENT_MOVE_PREFIX  = Prefix of ambient movement destination (waypoint or creature)
        AMBIENT_ANIM_PATTERN = Ambient animation pattern - index into ambient_ai.xls
        AMBIENT_ANIM_FREQ    = Animation frequency
                                    -1.0 = play all in order
                                     0.0 = no animations
                                     x.y = play random number (between x and y) animations in random order

        AMBIENT_ANIM_PATTERN_OVERRIDE = (Internal use) If non-zero, takes precedence over AMBIENT_ANIM_PATTERN
        AMBIENT_ANIM_FREQ_OVERRIDE    = (Internal use) If non-zero, takes precedence over AMBIENT_ANIM_FRE
        AMBIENT_ANIM_OVERRIDE_COUNT   = (Internal use) If non-zero, the number of times to play the override animation pattern before resuming the default animation pattern
        AMBIENT_ANIM_STATE   = (Internal use) Animation state: 0 = start move phase, -1 = start anim phase, +ve = # anims left to play
        AMBIENT_MOVE_STATE   = (Internal use) loword = # of the waypoint moved to last, hiword = direction of travel
        AMBIENT_MOVE_COUNT   = (Internal use) Number of NPC/WPs available to move to
*///////////////////////////////////////////////////////////////////////////////

#include "var_constants_h"
#include "log_h"
#include "events_h"
#include "utility_h"
#include "wrappers_h"
#include "sys_rubberband_h"

// AMBIENT_COMMAND constants
const int   AMBIENT_COMMAND_ATTACK_PRACTISE = 1; // Creature attacks target with 1-5s delay between attack commands.
const int   AMBIENT_COMMAND_ATTACK          = 2; // Creature attacks target with no delay between attack commands.

// AMBIENT_SYSTEM_STATE bit flags
const int   AMBIENT_SYSTEM_DISABLED  = 0x00;
const int   AMBIENT_SYSTEM_ENABLED   = 0x01;    // Indicates creature uses ambient behaviour.
const int   AMBIENT_SYSTEM_SPAWNSTART= 0x02;    // Indicates ambient behaviour starts when creature spawns.
const int   AMBIENT_SYSTEM_NOPLAYNEXT= 0x04;    // Forces the PlayNext parameter to CommandPlayAnimation to be FALSE.
const int   AMBIENT_SYSTEM_NOBLEND   = 0x08;    // Forces the BlendIn parameter to CommandPlayAnimation to be FALSE.
const int   AMBIENT_SYSTEM_ALWAYSON  = 0x10;    // Sets ambient behaviour to never stop (even during combat or when player remains out of sight).
const int   AMBIENT_SYSTEM_RUNNING   = 0x40;    // (Internal use) Indicates ambient movement/animation is in progress.

// AMBIENT_MOVE_PATTERN types
const int   AMBIENT_MOVE_INVALID     = -1;
const int   AMBIENT_MOVE_NONE        =  0;      // No movement
const int   AMBIENT_MOVE_PATROL      =  1;      // Patrol waypoints (1, 2, 3, 2, 1, ...)
const int   AMBIENT_MOVE_LOOP        =  2;      // Loop through waypoints (1, 2, 3, 1, 2, 3, ...)
const int   AMBIENT_MOVE_WARP        =  3;      // Jump from the last waypoint to the first (1, 2, 3, jump to 1, 2, 3, ...)
const int   AMBIENT_MOVE_RANDOM      =  4;      // Go to random waypoint
const int   AMBIENT_MOVE_WANDER      =  5;      // Go to random location within AMBIENT_RANGE_NEAR meters of home location
const int   AMBIENT_MOVE_WANDER_FAR  =  6;      // Go to random location within AMBIENT_RANGE_FAR meters of home location
const int   AMBIENT_MOVE_PATH_PATROL =  7;      // Follow waypoints using CommandMoveToMultiLocation() in order (1, 2, 3, 2, 1, ...)
const int   AMBIENT_MOVE_PATH_LOOP   =  8;      // Follow waypoints using CommandMoveToMultiLocation() in order (1, 2, 3, 1, 2, 3, ...)
const int   AMBIENT_MOVE_ONCE        =  9;      // Follow waypoints in order once (1, 2, 3)

// AMBIENT_ANIM_FREQ constants
const float AMBIENT_ANIM_FREQ_NONE   =  0.0f;
const float AMBIENT_ANIM_FREQ_ORDERED= -1.0f;
const float AMBIENT_ANIM_FREQ_RANDOM =  3.5f;

// AMBIENT_ANIM_STATE constants
const int   AMBIENT_ANIM_NONE        =  0;      // Indicates no animations remaining to play, ergo movement phase should begin next.
const int   AMBIENT_ANIM_RESET       = -1;      // Indicates movement phase complete and animation phase should begin next.

// AMBIENT_MOVE_STATE direction constants
const int   AMBIENT_MOVE_NEXT        = 0x00000; // Indicates waypoint travel in increasing numerical order
const int   AMBIENT_MOVE_PREV        = 0x10000; // Indicates waypoint travel in decreasing numerical order

// AMBIENT_MOVE_COUNT constants
const int   AMBIENT_MOVE_COUNT_INVALID  = -1;   // Indicates destination count needs to be (re)done.

// Time and distance constants
const float AMBIENT_SMALL_DELTA      =  0.01f;  // Small value used for floating point comparison.
const float AMBIENT_SMALL_DELAY      =  0.1f;   // Period to wait between ambient actions (in seconds).
const float AMBIENT_MOVE_TOLERANCE   =  2.0f;   // Move to target tolerance in metres
const float AMBIENT_RESUME_PERIOD    = 15.0f;   // Period to wait before attempting to resume ambient behaviour (in seconds).
const int   AMBIENT_PAUSE_PERIOD     = 30;      // Number of seconds the party must be out of range for a creature to pause ambient behaviour.
const int   AMBIENT_RANGE_NEAR       = 10;      // Range limit for wandering 'near' in metres.
const int   AMBIENT_RANGE_FAR        = 30;      // Range limit for wandering 'far' in metres.
const int   AMBIENT_LOOP_FOREVER     = 90;      // Any number of loops greater than this is considered infinite looping.

// String constants
const string AMBIENT_MOVE_PREFIX_NONE = "";

// 2DA column names in ambient_ai.xls
const string COL_AMBIENT_ANIM            = "Action";
const string COL_AMBIENT_ANIM_TOTAL      = "ActionTotal";
const string COL_AMBIENT_ANIM_NOPLAYNEXT = "NoPlayNext";

// Animation pattern constants corresponding to rows in ambient_ai.xls
const int AMBIENT_ANIM_PATTERN_NONE             =  0;
const int AMBIENT_ANIM_PATTERN_TWITCHES         =  1;
const int AMBIENT_ANIM_PATTERN_RELAXED_LOOP     =  2;
const int AMBIENT_ANIM_PATTERN_DOG_EATING       =  3;
const int AMBIENT_ANIM_PATTERN_RELAXED          =  4;
//const int AMBIENT_ANIM_PATTERN_GUARD_POST     =  5;
//const int AMBIENT_ANIM_PATTERN_GUARD_POST     =  6;
const int AMBIENT_ANIM_PATTERN_DEAD_LOOP        =  7;
const int AMBIENT_ANIM_PATTERN_BLESSING         =  8;
const int AMBIENT_ANIM_PATTERN_CROUCHPRAY_1     =  9;
const int AMBIENT_ANIM_PATTERN_LECTURER_1       = 10;
const int AMBIENT_ANIM_PATTERN_LISTENER_1       = 11;
const int AMBIENT_ANIM_PATTERN_LECTURER_2       = 12;
const int AMBIENT_ANIM_PATTERN_CHATTER_1        = 13;
const int AMBIENT_ANIM_PATTERN_LISTENER_2       = 14;
const int AMBIENT_ANIM_PATTERN_SHOPPER          = 15;
const int AMBIENT_ANIM_PATTERN_NURSE            = 16;
const int AMBIENT_ANIM_PATTERN_WRITHING         = 17;
const int AMBIENT_ANIM_PATTERN_TABLE_MAP        = 18;
const int AMBIENT_ANIM_PATTERN_CROSSARMS_LOOP   = 19;
const int AMBIENT_ANIM_PATTERN_MERCHANT_BECKON  = 20;
const int AMBIENT_ANIM_PATTERN_CLEAN_FLOOR      = 22;
const int AMBIENT_ANIM_PATTERN_SITGROUND_LOOP   = 23;
const int AMBIENT_ANIM_PATTERN_WANDER_LR        = 24;
const int AMBIENT_ANIM_PATTERN_HANDSBACK_LOOP_1 = 25;   // without enter animation
const int AMBIENT_ANIM_PATTERN_ATTENTION        = 26;
const int AMBIENT_ANIM_PATTERN_PRE_LOGHAIN      = 27;
const int AMBIENT_ANIM_PATTERN_WANDER_R         = 28;
const int AMBIENT_ANIM_PATTERN_WANDER_L         = 29;
const int AMBIENT_ANIM_PATTERN_DARKSPAWN_WANDER = 30;
const int AMBIENT_ANIM_PATTERN_CROUCH_LOOP      = 31;
const int AMBIENT_ANIM_PATTERN_PRAY_LOOP        = 32;
const int AMBIENT_ANIM_PATTERN_CROUCHPRAY_2     = 33;
const int AMBIENT_ANIM_PATTERN_HANDSBACK_LOOP_2 = 34;   // with enter animation
const int AMBIENT_ANIM_PATTERN_RUMMAGING        = 35;
const int AMBIENT_ANIM_PATTERN_DEER_GRAZING_1   = 59;
const int AMBIENT_ANIM_PATTERN_DEER_GRAZING_2   = 60;

const int AMBIENT_ANIM_PATTERN_TEST             = 1000;
const int AMBIENT_ANIM_PATTERN_TEST_LONG        = 1001;


////////////////////////////////////////////////////////////////////////////////
/** @brief Triggers ambient commands.
*
*   @param oCreature  The creature to assign an ambient command.
*   @param nCommand   The command to perform (AMBIENT_COMMAND_***). If zero, uses the AMBIENT_COMMAND local integer set on oCreature.
*   @returns          TRUE if oCreature has an ambient command to perform. FALSE otherwise.
**//////////////////////////////////////////////////////////////////////////////
int Ambient_DoCommand(object oCreature = OBJECT_SELF, int nCommand = 0);

////////////////////////////////////////////////////////////////////////////////
/** @brief  Causes a creature to perform an ambient behaviour (i.e. a single movement or animation).
*
*   @param  oCreature        The creature.
*   @param  bUpdateTimer
**//////////////////////////////////////////////////////////////////////////////
void Ambient_DoSomething(object oCreature = OBJECT_SELF, int bUpdateTimer = FALSE);


////////////////////////////////////////////////////////////////////////////////
/** @brief Starts (or restarts) a creature's ambient behaviour.
*
*   @param oCreature        The creature to perform ambient behaviour.
*   @param nAmbientState    If non-zero this replaces the AMBIENT_SYSTEM_STATE flag on oCreature.
*   @param nMovePattern     If non-negative this replaces the AMBIENT_MOVE_PATTERN variable on oCreature.
*   @param sMovePrefix      If non-empty this replaces the AMBIENT_MOVE_PREFIX variable on oCreature.
*   @param nAnimPattern     If non-zero this replaces the AMBIENT_ANIM_PATTERN variable on oCreature.
*   @param fAnimFreq        If non-zero this replaces the AMBIENT_ANIM_FREQ variable on oCreature.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_Start(object oCreature = OBJECT_SELF, int nAmbientState = AMBIENT_SYSTEM_ENABLED, int nMovePattern = AMBIENT_MOVE_INVALID, string sMovePrefix = AMBIENT_MOVE_PREFIX_NONE, int nAnimPattern = AMBIENT_ANIM_PATTERN_NONE, float fAnimFreq = AMBIENT_ANIM_FREQ_NONE)
{
    if (!GetObjectActive(oCreature) || GetObjectType(oCreature) != OBJECT_TYPE_CREATURE || IsDead(oCreature) || IsDying(oCreature) || IsPartyMember(oCreature))
        return;

    if (!nAmbientState)
        nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);

    if (nAmbientState &amp; AMBIENT_SYSTEM_ENABLED)
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Start()", ToString(oCreature));

        if (nMovePattern != AMBIENT_MOVE_INVALID)
            SetLocalInt(oCreature, AMBIENT_MOVE_PATTERN, nMovePattern);

        if (sMovePrefix != AMBIENT_MOVE_PREFIX_NONE)
            SetLocalString(oCreature, AMBIENT_MOVE_PREFIX, sMovePrefix);

        if (nAnimPattern)
            SetLocalInt(oCreature, AMBIENT_ANIM_PATTERN, nAnimPattern);

        if (fabs(fAnimFreq) &gt; AMBIENT_SMALL_DELTA)
            SetLocalFloat(oCreature, AMBIENT_ANIM_FREQ, fAnimFreq);

        SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState);
        SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_RESET);

        Ambient_DoSomething(oCreature);
    }
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Starts (or restarts) ambient behaviour of a team of creatures.
*
*   @param nTeam            The ID of the team of creatures.
*   @param nAmbientState    If non-zero this replaces the AMBIENT_SYSTEM_STATE flag on oCreature.
*   @param nMovePattern     If non-negative this replaces the AMBIENT_MOVE_PATTERN variable on oCreature.
*   @param sMovePrefix      If non-empty this replaces the AMBIENT_MOVE_PREFIX variable on oCreature.
*   @param nAnimPattern     If non-zero this replaces the AMBIENT_ANIM_PATTERN variable on oCreature.
*   @param fAnimFreq        If non-zero this replaces the AMBIENT_ANIM_FREQ variable on oCreature.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_StartTeam(int nTeam, int nAmbientState = AMBIENT_SYSTEM_ENABLED, int nMovePattern = AMBIENT_MOVE_INVALID, string sMovePrefix = AMBIENT_MOVE_PREFIX_NONE, int nAnimPattern = AMBIENT_ANIM_PATTERN_NONE, float fAnimFreq = AMBIENT_ANIM_FREQ_NONE)
{
    object[] arCreature = GetTeam(nTeam);
    int n = GetArraySize(arCreature);
    int i = 0;

    for (i = 0; i &lt; n; i++)
    {
        Ambient_Start(arCreature[i], nAmbientState, nMovePattern, sMovePrefix, nAnimPattern, fAnimFreq);
    }
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Starts (or restarts) ambient behaviour of all creatures with a given tag.
*
*   @param sTag             The tag of the creature(s).
*   @param nAmbientState    If non-zero this replaces the AMBIENT_SYSTEM_STATE flag on oCreature.
*   @param nMovePattern     If non-negative this replaces the AMBIENT_MOVE_PATTERN variable on oCreature.
*   @param sMovePrefix      If non-empty this replaces the AMBIENT_MOVE_PREFIX variable on oCreature.
*   @param nAnimPattern     If non-zero this replaces the AMBIENT_ANIM_PATTERN variable on oCreature.
*   @param fAnimFreq        If non-zero this replaces the AMBIENT_ANIM_FREQ variable on oCreature.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_StartTag(string sTag, int nAmbientState = AMBIENT_SYSTEM_ENABLED, int nMovePattern = AMBIENT_MOVE_INVALID, string sMovePrefix = AMBIENT_MOVE_PREFIX_NONE, int nAnimPattern = AMBIENT_ANIM_PATTERN_NONE, float fAnimFreq = AMBIENT_ANIM_FREQ_NONE)
{
    object[] arCreature = GetNearestObjectByTag(GetHero(), sTag, OBJECT_TYPE_CREATURE, 20);
    int n = GetArraySize(arCreature);
    int i = 0;

    for (i = 0; i &lt; n; i++)
    {
        Ambient_Start(arCreature[i], nAmbientState, nMovePattern, sMovePrefix, nAnimPattern, fAnimFreq);
    }
}


////////////////////////////////////////////////////////////////////////////////
/** @brief  Checks whether to start ambient behaviour after creature spawns.
*
*   Called from creature's EVENT_TYPE_SPAWN handler. Starts ambient behaviour
*   if the local variable AMBIENT_SYSTEM_STATE bit mask contains 0x02
*   (AMBIENT_SYSTEM_SPAWNSTART). Generally, only creatures with a single
*   infinitely looping animation should have this bit set.
*
*   @param  oCreature        The creature.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_SpawnStart(object oCreature = OBJECT_SELF)
{
    if (!GetObjectActive(oCreature) || GetObjectType(oCreature) != OBJECT_TYPE_CREATURE || IsDead(oCreature) || IsDying(oCreature) || IsPartyMember(oCreature))
        return;

    int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);

    // Hack: Originally AMBIENT_COMMAND didn't require the AMBIENT_SYSTEM_ENABLED bit set. Now it does, so flip the bit here.
    if (GetLocalInt(oCreature, AMBIENT_COMMAND))
    {
        nAmbientState |= AMBIENT_SYSTEM_SPAWNSTART;
    }

    if (nAmbientState &amp; AMBIENT_SYSTEM_SPAWNSTART)
    {
        // Start ambient behaviour.
        nAmbientState |= AMBIENT_SYSTEM_ENABLED;
        SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState);
        SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_RESET);

        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_SpawnStart()", "AMBIENT_SYSTEM_STATE: " + IntToHexString(nAmbientState));

        Ambient_DoSomething(oCreature);
    }
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Disables ambient behaviour for a creature.
*
*   @param oCreature    The creature.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_Stop(object oCreature = OBJECT_SELF)
{
    Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Stop()");

    int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);
    SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState &amp; ~AMBIENT_SYSTEM_ENABLED);
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Causes a creature to move a random distance away from its home location.
*
*   @param  oCreature   The creature moving.
*   @param  nRange      Maximum distance (in meters) oCreature can wander from home location.
*   @param  bRun        Whether the creature should walk or run.
*   @returns            TRUE if function succeeds (i.e. creature moves to a valid location).
**//////////////////////////////////////////////////////////////////////////////
int Ambient_MoveRandom(object oCreature, int nRange, int bRun = FALSE)
{
    vector vHome   = GetPositionFromLocation(Rubber_GetHome(oCreature));
    location lDest = Location(GetArea(oCreature),
                              Vector(vHome.x + RandomF(2*nRange, -nRange), vHome.y + RandomF(2*nRange, -nRange), vHome.z),
                              0.0f);
    WR_AddCommand(oCreature, CommandMoveToLocation(lDest, bRun));
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Gets the number of objects a creature can move to through ambient movement.
*
*   Gets the number of objects a creature can move to through ambient movement.
*   The destinations can be waypoints, placeables, or creatures. Expected tag
*   convention is either sequential unique objects (XXX_01, XXX_02, XXX_03, etc.) or
*   all objects sharing a single common tag (XXX) where XXX is the AMBIENT_MOVE_PREFIX
*   local variable set on the creature.
*
*   @param    oCreature  The creature whose destinations to count.
*   @returns             The number of valid destinations for oCreature.
**//////////////////////////////////////////////////////////////////////////////
object[] Ambient_GetDestinations(object oCreature)
{
    string   sWP = ReplaceString(GetLocalString(oCreature, AMBIENT_MOVE_PREFIX), "&lt;tag&gt;", GetTag(oCreature));
    object[] aWP;
    object   oWP;
    int      i;

    for (i = 0; IsObjectValid(oWP = GetObjectByTag(sWP + "_" + (i+1 &lt; 10 ? "0" : "") + ToString(i+1))); i++)
        aWP[i] = oWP;

    if (GetArraySize(aWP) == 0)
    {
        // Hack for non-existent engine function GetObjectsByTag()
        for (i = 0; IsObjectValid(oWP = GetObjectByTag(sWP, i)); i++)
            aWP[i] = oWP;
    }
    return aWP;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Gets the Nth ambient destination for a creature.
*
*   See Ambient_GetDestinations() for a description of the expected tag format.
*
*   @param oCreature    The creature moving.
*   @param n            The number of the destination.
*   @returns            The Nth destination object or OBJECT_INVALID.
**//////////////////////////////////////////////////////////////////////////////
object Ambient_GetDestination(object oCreature, int n)
{
    string sWP = ReplaceString(GetLocalString(oCreature, AMBIENT_MOVE_PREFIX), "&lt;tag&gt;", GetTag(oCreature));
    object oWP = GetObjectByTag(sWP + "_" + (n &lt; 10 ? "0" : "") + ToString(n));
    if (!IsObjectValid(oWP))
        oWP = GetObjectByTag(sWP, n-1);   // subtract 1 since GetObjectByTag() is zero-based.

    if (!IsObjectValid(oWP))
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_GetDestination()", "Failed to find valid destination: " + sWP);

    return oWP;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Causes a creature to walk between a set of objects (typically waypoints).
*
*   @param oCreature        The creature moving.
*   @param nMovementPattern The pattern of movement between objects (loop, patrol, random, etc).
*   @param bRun             Whether the creature should walk or run to the next waypoint.
*   @returns                TRUE if function succeeds (i.e. creature moves to a valid location).
**//////////////////////////////////////////////////////////////////////////////
int Ambient_WalkWaypoints(object oCreature, int nMovementPattern, int bRun = FALSE)
{
    int cWP = GetLocalInt(oCreature, AMBIENT_MOVE_COUNT);   // Number of destinations available to move to.
    if (cWP == AMBIENT_MOVE_COUNT_INVALID)
    {
        // Calculate and cache destination count
        cWP = GetArraySize(Ambient_GetDestinations(oCreature));
        SetLocalInt(oCreature, AMBIENT_MOVE_COUNT, cWP);
        SetLocalInt(oCreature, AMBIENT_MOVE_STATE, AMBIENT_MOVE_NEXT);
    }

    if (cWP == 0)
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_WalkWaypoints()", "No valid destinations.");
        WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
        return FALSE;
    }

    int    nMoveState = GetLocalInt(oCreature, AMBIENT_MOVE_STATE);
    int    nWP        = nMoveState &amp; 0x0000FFFF;    // loword = The number of the object/waypoint last moved to.
    int    nMoveDir   = nMoveState &amp; 0xFFFF0000;    // hiword = Direction of travel.
    int    bJump      = FALSE;

/*
    if (nWP == cWP &amp;&amp; cWP == 1)
    {
        // There's only 1 ambient waypoint and creature is already at it.
        WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
        return FALSE;
    }
*/

    // Figure out next destination.
    switch (nMovementPattern)
    {
        case AMBIENT_MOVE_PATROL:     // 1,2,3,2,1,2,3, etc
        {
            if (nMoveDir == AMBIENT_MOVE_NEXT)
            {
                nWP++;
                if (nWP &gt; cWP)
                {
                    nWP -= 2;
                    nMoveDir = AMBIENT_MOVE_PREV;
                }
            }
            else
            {
                nWP--;
                if (nWP &lt; 1)
                {
                    nWP += 2;
                    nMoveDir = AMBIENT_MOVE_NEXT;
                }
            }
            break;
        }
        case AMBIENT_MOVE_LOOP:       // 1,2,3,1,2,3, etc
        {
            nWP++;
            if (nWP &gt; cWP)
                nWP = 1;
            break;
        }
        case AMBIENT_MOVE_WARP:       // 1,2,3,jump to 1,2,3, etc
        {
            nWP++;
            if (nWP &gt; cWP)
            {
                nWP = 1;
                bJump = TRUE;
            }
            break;
        }
        case AMBIENT_MOVE_ONCE:
        {
            nWP++;
            if (nWP &gt; cWP)
            {
                // Reached last waypoint.
                SetLocalInt(oCreature, AMBIENT_MOVE_PATTERN, AMBIENT_MOVE_NONE);
                SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_RESET);
                return FALSE;
            }
            break;
        }
        case AMBIENT_MOVE_RANDOM:     // any destination other than current one
        {
            int r = Random(cWP) + 1;
            while (cWP &gt; 1 &amp;&amp; r == nWP)
                r = Random(cWP) + 1;
            nWP = r;
            break;
        }
        default:
        {
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_WalkWaypoints()", "Invalid movement pattern: " + ToString(nMovementPattern));
        }
    }

    object oWP = Ambient_GetDestination(oCreature, nWP);
    if (IsObjectValid(oWP))
    {
        SetLocalInt(oCreature, AMBIENT_MOVE_STATE, nMoveDir + nWP);

        if (bJump)
        {
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_WalkWaypoints()", "Jump to: " + ToString(oWP));
            WR_AddCommand(oCreature, CommandJumpToLocation(GetLocation(oWP)));
        }
        else
        {
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_WalkWaypoints()", "Move to: " + ToString(oWP));
            WR_AddCommand(oCreature, CommandMoveToLocation(GetLocation(oWP), bRun));
        }
        return TRUE;

    }

    // Found no valid location to move to
    WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
    SetLocalInt(oCreature, AMBIENT_MOVE_STATE,  AMBIENT_MOVE_NEXT);
    SetLocalInt(oCreature, AMBIENT_MOVE_COUNT, AMBIENT_MOVE_COUNT_INVALID); // Force recount of destinations next invocation
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Causes a creature to follow a prescribed path using CommandMoveToMultiLocations().
*
*   @param  oCreature   The ambient creature.
*   @param  bLoop       Whether the creature should loop or patrol waypoints.
*   @param  bRun        Whether the creature should walk or run between waypoints.
*   @returns            TRUE if function succeeds (i.e. creature moves to a valid location).
**//////////////////////////////////////////////////////////////////////////////
int Ambient_MovePath(object oCreature, int bLoop, int bRun)
{
    object[] aWP = Ambient_GetDestinations(oCreature);
    int      cWP = GetArraySize(aWP);

    if (cWP == 0)
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_MovePath()", "No valid destinations.");
        WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
        return FALSE;
    }

    int    nMoveState = GetLocalInt(oCreature, AMBIENT_MOVE_STATE);
    int    nWP        = nMoveState &amp; 0x0000FFFF;    // loword = The number of the object/waypoint last moved to.
    int    nMoveDir   = nMoveState &amp; 0xFFFF0000;    // hiword = Direction of travel.

    if ((nWP + 1) &gt;= cWP)
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_MovePath()", "nWP + 1 &gt;= cWP (" + ToString(nWP) + " + 1 &gt;= " + ToString(cWP) + ") -&gt; changing direction");
        nMoveDir = (nMoveDir == AMBIENT_MOVE_NEXT) ? AMBIENT_MOVE_PREV : AMBIENT_MOVE_NEXT;
        nWP = 0;
    }

    location[] lWP;
    int        i;
    for (i = 0; i &lt; cWP; i++)
    {
        if (!bLoop &amp;&amp; nMoveDir == AMBIENT_MOVE_PREV)
            lWP[i] = GetLocation(aWP[cWP - i - 1]);
        else
            lWP[i] = GetLocation(aWP[i]);
    }

    Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_MovePath()", "Moving to destination " + ToString(nWP) + " of " + ToString(cWP));
    SetLocalInt(oCreature, AMBIENT_MOVE_STATE, nMoveDir + nWP);
    WR_AddCommand(oCreature, CommandMoveToMultiLocations(lWP, bRun, nWP));
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Handler for EVENT_TYPE_REACHED_WAYPOINT event.
*
*   @param   ev     The EVENT_TYPE_REACHED_WAYPOINT event.
*   @returns        TRUE if creature moved to waypoint because of ambient behaviour.
**//////////////////////////////////////////////////////////////////////////////
int Ambient_ReachedWaypoint(event ev)
{
    int bEventHandled = FALSE;
    object oCreature  = GetEventCreator(ev);
    int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);
    int nMovePattern  = GetLocalInt(oCreature, AMBIENT_MOVE_PATTERN) % 10;

    if ((nAmbientState &amp; AMBIENT_SYSTEM_ENABLED)
        &amp;&amp; (nMovePattern == AMBIENT_MOVE_PATH_PATROL || nMovePattern == AMBIENT_MOVE_PATH_LOOP))
    {
        int nWP        = GetEventInteger(ev, 0);
        int nMoveState = GetLocalInt(oCreature, AMBIENT_MOVE_STATE);
        int nMoveDir   = nMoveState &amp; 0xFFFF0000;    // hiword = Direction of travel.

        SetLocalInt(oCreature, AMBIENT_MOVE_STATE, nMoveDir + nWP + 1); // Add 1 since nWP is zero-based.
        bEventHandled = TRUE;
    }
    return bEventHandled;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Checks whether a creature has reached to its final destination.
*
*   @param   oCreature  The ambient creature.
*   @returns TRUE if oCreature is within a reasonable tolerance of the destination
*            to which it was last told to move.
**//////////////////////////////////////////////////////////////////////////////
int Ambient_ReachedDestination(object oCreature)
{
    int nMovePattern = GetLocalInt(oCreature, AMBIENT_MOVE_PATTERN);
    int nRunChance   = nMovePattern / 10;     // 2nd digit is the likelihood (0-9) of running (0 = 0%, 1 = 10%, etc).
    nMovePattern     = nMovePattern % 10;     // 1st digit is the 'real' move pattern.
    int nMoveState   = GetLocalInt(oCreature, AMBIENT_MOVE_STATE);
    int nWP          = nMoveState &amp; 0x0000FFFF;    // loword = The number of the object/waypoint last moved to.

    switch (nMovePattern)
    {
        case AMBIENT_MOVE_PATROL:
        case AMBIENT_MOVE_LOOP:
        case AMBIENT_MOVE_WARP:
        case AMBIENT_MOVE_ONCE:
        case AMBIENT_MOVE_RANDOM:
        case AMBIENT_MOVE_WANDER:
        case AMBIENT_MOVE_WANDER_FAR:
        {
            if (nWP)
            {
                object oWP = Ambient_GetDestination(oCreature, nWP);
                if (IsObjectValid(oWP))
                {
                    // Keep moving if too far from destination.
                    if (GetDistanceBetween(oCreature, oWP) &gt; AMBIENT_MOVE_TOLERANCE)
                    {
                        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_ReachedDestination()", "Moving to: " + ToString(oWP));
                        WR_AddCommand(oCreature, CommandWait(5.0f));
                        WR_AddCommand(oCreature, CommandMoveToLocation(GetLocation(oWP), (nRunChance &gt; Random(10))));
                        return FALSE;
                    }
                }
            }
            break;
        }
        case AMBIENT_MOVE_PATH_PATROL:
        case AMBIENT_MOVE_PATH_LOOP:
        {
            int cWP = GetLocalInt(oCreature, AMBIENT_MOVE_COUNT);
            if (cWP == AMBIENT_MOVE_COUNT_INVALID)
            {
                object[] aWP = Ambient_GetDestinations(oCreature);
                cWP = GetArraySize(aWP);
                SetLocalInt(oCreature, AMBIENT_MOVE_COUNT, cWP);
            }

            if (cWP &gt; 0 &amp;&amp; (nWP + 1) &lt; cWP)
            {
                Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_ReachedDestination()", "nWP + 1 &lt; cWP (" + ToString(nWP) + " + 1 &lt; " + ToString(cWP) + ") -&gt; not there yet");
                WR_AddCommand(oCreature, CommandWait(5.0f));
                Ambient_MovePath(oCreature, (nMovePattern == AMBIENT_MOVE_PATH_LOOP), (nRunChance &gt; Random(10)));
                return FALSE;
            }

            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_ReachedDestination()", "nWP + 1 &gt;= cWP (" + ToString(nWP) + " + 1 &gt;= " + ToString(cWP) + ") -&gt; reached destination");
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_ReachedDestination()", "AMBIENT_ANIM_STATE: " + ToString(GetLocalInt(oCreature, AMBIENT_ANIM_STATE)));
            break;
        }
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Triggers next action in an ambient behaviour animation phase.
*
*   Causes oCreature to perform the next action in an ambient behaviour animation phase.
*   Once oCreature runs out of actions to perform, a movement phase is triggered.
*
*   @param oCreature  The creature animating.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_Animate(object oCreature)
{
    int   nAnimsToDo   = GetLocalInt(oCreature, AMBIENT_ANIM_STATE);
    int   nAnimPattern = GetLocalInt(oCreature, AMBIENT_ANIM_PATTERN_OVERRIDE);
    float fAnimFreq    = GetLocalFloat(oCreature, AMBIENT_ANIM_FREQ_OVERRIDE);

    // Decrement number of times to play override animations
    int nOverrideCount = GetLocalInt(oCreature, AMBIENT_ANIM_OVERRIDE_COUNT);
    if (nAnimsToDo == AMBIENT_ANIM_RESET &amp;&amp; nOverrideCount &gt; 0)
    {
        SetLocalInt(oCreature, AMBIENT_ANIM_OVERRIDE_COUNT, --nOverrideCount);
    }

    // If override count reaches zero then clear override animation pattern &amp; frequency.
    if (nOverrideCount == 0)
    {
        int   nAnimPattern = AMBIENT_ANIM_PATTERN_NONE;
        float fAnimFreq    = AMBIENT_ANIM_FREQ_NONE;
        SetLocalInt(oCreature, AMBIENT_ANIM_PATTERN_OVERRIDE, AMBIENT_ANIM_PATTERN_NONE);
        SetLocalFloat(oCreature, AMBIENT_ANIM_FREQ_OVERRIDE, AMBIENT_ANIM_FREQ_NONE);
    }

    // Load default animation pattern and frequency if no override values
    if (nAnimPattern == AMBIENT_ANIM_PATTERN_NONE)
        nAnimPattern = GetLocalInt(oCreature, AMBIENT_ANIM_PATTERN);
    if (fabs(fAnimFreq) &lt; AMBIENT_SMALL_DELTA)
        fAnimFreq = GetLocalFloat(oCreature, AMBIENT_ANIM_FREQ);

    if (nAnimPattern &lt;= 0)
    {
        // No animation pattern so trigger movement if movement pattern specified.
        SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_NONE);
        if (GetLocalInt(oCreature, AMBIENT_MOVE_PATTERN) % 10)
        {
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Animate()", "No AMBIENT_ANIM_PATTERN");
            WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
            return;
        }

        // Creature has no animation pattern or move pattern assigned so default
        // to playing random idle twitches (otherwise creature remains frozen in
        // last animation when returning from staged conversation).
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Animate()", " *** No AMBIENT_ANIM_PATTERN or AMBIENT_MOVE_PATTERN ***");

        nAnimsToDo   = AMBIENT_ANIM_RESET;
        nAnimPattern = AMBIENT_ANIM_PATTERN_TWITCHES;
        fAnimFreq    = AMBIENT_ANIM_FREQ_RANDOM;

        SetLocalInt(oCreature, AMBIENT_ANIM_PATTERN, nAnimPattern);
        SetLocalFloat(oCreature, AMBIENT_ANIM_FREQ, fAnimFreq);
    }

    if (fabs(fAnimFreq) &lt; AMBIENT_SMALL_DELTA)
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Animate()", "No AMBIENT_ANIM_FREQ");

        // Trigger movement if valid (check first to prevent endless cycling).
        SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_NONE);
        if (GetLocalInt(oCreature, AMBIENT_MOVE_PATTERN) % 10)
            WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
        return;
    }

    if (nAnimsToDo == AMBIENT_ANIM_RESET)
    {
        // Start of animation phase - determine number to play.
        // fAnimFreq format: min.max (-1.0 to play all in sequence)
        if (fAnimFreq &lt; 0.0f)
        {
            // -1.0 = play all animations (AMBIENT_ANIM_FREQ_ORDERED)
            nAnimsToDo = GetM2DAInt(TABLE_AMBIENT, COL_AMBIENT_ANIM_TOTAL, nAnimPattern);
        }
        else
        {
            // Choose random number of animations
            int nMin = FloatToInt(fAnimFreq);
            int nMax = FloatToInt((fAnimFreq - nMin) * 10);
            nAnimsToDo = Random(abs(nMax-nMin)) + Min(nMin, nMax);
        }
    }

    if (nAnimsToDo == 0)
    {
        // No animations - trigger movement if valid (check first to prevent endless cycling).
        SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_NONE);
        if (GetLocalInt(oCreature, AMBIENT_MOVE_PATTERN) % 10)
            WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
        return;
    }

    if (nAnimsToDo &gt; 0)     // Pick and play an animation from 2DA
    {
        int nAnims = GetM2DAInt(TABLE_AMBIENT, COL_AMBIENT_ANIM_TOTAL, nAnimPattern);
        if (nAnims == 0)
        {
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Animate()", "No animations for nAnimPattern: " + ToString(nAnimPattern));

            // Trigger movement if valid (check first to prevent endless cycling).
            SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_NONE);
            if (GetLocalInt(oCreature, AMBIENT_MOVE_PATTERN) % 10)
                WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
            return;
        }

        float fAction = 0.0f;   // Action format: animation.loops
        if (fAnimFreq &lt; 0.0f)
        {
            // If pattern has changed, we may have to reset if it has less
            // animations than before
            if(nAnimsToDo &gt; nAnims)
            {
                nAnimsToDo = nAnims;
            }

            // Select next action in sequence
            fAction = GetM2DAFloat(TABLE_AMBIENT, COL_AMBIENT_ANIM + ToString(nAnims - nAnimsToDo), nAnimPattern);
        }
        else
        {
            // Select random action
            fAction = GetM2DAFloat(TABLE_AMBIENT, COL_AMBIENT_ANIM + ToString(Random(nAnims)), nAnimPattern);
        }

        // If fAction is positive then it's an animation, otherwise it's a placeable interaction.
        if (fAction &gt; 0.0)
        {
            // Parse animation (left of decimal) and number of loops (right of decimal) from action.
            int nAnimation = FloatToInt(fAction);
            int nLoops     = FloatToInt((fAction - nAnimation) * 100);

            if (nAnimation &gt; 0)
            {
                int bBlend    = !(GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE) &amp; AMBIENT_SYSTEM_NOBLEND);

                // If NoPlayNext bit is set on the creature, respect it. Otherwise, use value set in 2da.
                int bPlayNext = !(GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE) &amp; AMBIENT_SYSTEM_NOPLAYNEXT);
                if (bPlayNext)
                    bPlayNext = !(GetM2DAInt(TABLE_AMBIENT, COL_AMBIENT_ANIM_NOPLAYNEXT, nAnimPattern));
                if (nAnimation == 1)
                    bPlayNext = TRUE;

                Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Animate()", "Animation: " + ToString(nAnimation)
                    + ((nLoops &gt; 0) ? (", Loops: " + ToString(nLoops)) : (""))
                    + ", PlayNext: " + ToString(bPlayNext) + ", Blend: " + ToString(bBlend)
                    + ", nAnimsToDo: " + ToString(nAnimsToDo) + ", nAnimsTotal: " + ToString(nAnims)
                    + ", Pattern: " + ToString(nAnimPattern));

                WR_AddCommand(oCreature, CommandPlayAnimation(nAnimation, (nLoops &gt;= AMBIENT_LOOP_FOREVER) ? -1 : nLoops, bPlayNext, bBlend));

                // Mark as busy to prevent generation of EVENT_TYPE_AMBIENT_CONTINUE events by engine.
                if (nLoops &gt; 0)
                {
                    int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);
                    SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState | AMBIENT_SYSTEM_RUNNING);
                }
            }
        }
        else
        {
            // Parse interaction (left of decimal) and number of loops (right of decimal) from action.
            int nInteraction = FloatToInt(fabs(fAction));
            int nLoops       = FloatToInt((fabs(fAction) - nInteraction) * 100);
            int nPose        = 1;

            if (nInteraction &gt; 0)
            {
                object[] aPlc = GetNearestObject(oCreature, OBJECT_TYPE_PLACEABLE);
                if (GetArraySize(aPlc) &gt; 0)
                {
                    object oTarget = aPlc[0];
                    int bPlayNext  = !(GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE) &amp; AMBIENT_SYSTEM_NOPLAYNEXT);
                    int bBlend     = !(GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE) &amp; AMBIENT_SYSTEM_NOBLEND);

                    Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Animate()", "Interaction: " + ToString(nInteraction)
                        + ((nLoops &gt; 0) ? (", Loops: " + ToString(nLoops)) : (""))
                        + ", PlayNext: " + ToString(bPlayNext) + ", Blend: " + ToString(bBlend)
                        + ", nAnimsToDo: " + ToString(nAnims - nAnimsToDo) + "/" + ToString(nAnims)
                        + ", Pattern: " + ToString(nAnimPattern));

                    InteractWithObject(oCreature, oTarget, nInteraction, 1, (nLoops &gt;= AMBIENT_LOOP_FOREVER) ? -1 : nLoops, bPlayNext, FALSE);

                    // Mark as busy to prevent generation of EVENT_TYPE_AMBIENT_CONTINUE events by engine.
                    if (nLoops &gt; 0)
                    {
                        int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);
                        SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState | AMBIENT_SYSTEM_RUNNING);
                    }
                }
            }
        }
    }

    // Decrement number of animations remaining to play.
    // A movement phase is triggered when no more animations remain.
    SetLocalInt(oCreature, AMBIENT_ANIM_STATE, --nAnimsToDo);
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Triggers an ambient behaviour movement phase.
*
*   Causes oCreature to move to a new location/waypoint. Once oCreature
*   reaches its destination it will begin an ambient behaviour animation phase.
*
*   @param oCreature  The creature moving.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_Move(object oCreature)
{
    int bMoving = FALSE;

    int nMovePattern = GetLocalInt(oCreature, AMBIENT_MOVE_PATTERN);

    int nRunChance = nMovePattern / 10;     // 2nd digit is the likelihood (0-9) of running (0 = 0%, 1 = 10%, etc).
    int bRun       = (nRunChance &gt; Random(9));

    nMovePattern   = nMovePattern % 10;     // 1st digit is the 'real' move pattern.

    switch (nMovePattern)
    {
        case AMBIENT_MOVE_NONE:
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Move()", "No AMBIENT_MOVE_PATTERN");

            // Not moving so do animation phase instead.
            if ((GetLocalInt(oCreature, AMBIENT_ANIM_PATTERN) || GetLocalInt(oCreature, AMBIENT_ANIM_PATTERN_OVERRIDE)))
            {
                SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_RESET);
                Ambient_Animate(oCreature);
                return;
            }
            break;
        case AMBIENT_MOVE_PATROL:
        case AMBIENT_MOVE_LOOP:
        case AMBIENT_MOVE_WARP:
        case AMBIENT_MOVE_ONCE:
        case AMBIENT_MOVE_RANDOM:
            bMoving = Ambient_WalkWaypoints(oCreature, nMovePattern, bRun);
            break;
        case AMBIENT_MOVE_WANDER:
            bMoving = Ambient_MoveRandom(oCreature, AMBIENT_RANGE_NEAR, bRun);
            break;
        case AMBIENT_MOVE_WANDER_FAR:
            bMoving = Ambient_MoveRandom(oCreature, AMBIENT_RANGE_FAR, bRun);
            break;
        case AMBIENT_MOVE_PATH_PATROL:
        case AMBIENT_MOVE_PATH_LOOP:
            bMoving = Ambient_MovePath(oCreature, (nMovePattern == AMBIENT_MOVE_PATH_LOOP), bRun);
            break;
        default:
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_Move()", "Invalid AMBIENT_MOVE_PATTERN");

            // Trigger animation phase if valid and not already doing looping animation (check first to prevent endless cycling).
            if ((GetLocalInt(oCreature, AMBIENT_ANIM_PATTERN) || GetLocalInt(oCreature, AMBIENT_ANIM_PATTERN_OVERRIDE)))
                WR_AddCommand(oCreature, CommandWait(AMBIENT_SMALL_DELAY));
    }
/*    
    if (bMoving)
    {
        // Mark as busy to prevent generation of EVENT_TYPE_AMBIENT_CONTINUE events by engine.
        int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);
        SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState | AMBIENT_SYSTEM_RUNNING);
    }
*/    
    // Movement phase done - animation phase is next.
    SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_RESET);
}
         

////////////////////////////////////////////////////////////////////////////////
/** @brief  Checks period since last EVENT_AMBIENT_CONTINUE event was received.
*
*   @param  oCreature       The creature performing the ambient behaviour.
*   @param  bUpdateTimer    TRUE if timer should be updated with current timestamp.
*   @returns                TRUE if timer expired (meaning creature should cease ambient animations)
**//////////////////////////////////////////////////////////////////////////////
int Ambient_TimerExpired(object oCreature, int bUpdateTimer)
{
    int nTimeNow  = GetLowResTimer();
    int nTimeLast = GetLocalInt(oCreature, AMBIENT_TICK_COUNT);

    if (nTimeLast == 0)
        nTimeLast = nTimeNow;

    if (bUpdateTimer)
    {
        SetLocalInt(oCreature, AMBIENT_TICK_COUNT, nTimeNow);
    }
    else if (abs(nTimeNow - nTimeLast) &gt; AMBIENT_PAUSE_PERIOD * 1000)
    {
        // Pause ambient behaviour if party out of range for too long.
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_TimerExpired()", "Pausing (" + ToString(nTimeNow) + " - " + ToString(nTimeLast) + " = " + ToString(nTimeNow-nTimeLast));
        SetLocalInt(oCreature, AMBIENT_TICK_COUNT, 0);
        return TRUE;
    }              
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
/** @brief  Causes a creature to perform the next appropriate ambient behaviour (i.e. movement or animation).
*
*   @param  oCreature       The creature performing the ambient behaviour.
*   @param  bUpdateTimer
**//////////////////////////////////////////////////////////////////////////////
void Ambient_DoSomething(object oCreature = OBJECT_SELF, int bUpdateTimer = FALSE)
{
    if (!GetObjectActive(oCreature) || IsDead(oCreature) || IsPartyMember(oCreature))
        return;

    int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);

    // Check whether ambient behaviour is enabled.
    if (!(nAmbientState &amp; AMBIENT_SYSTEM_ENABLED))
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoSomething()", "AMBIENT_SYSTEM_ENABLED bit not set (nAmbientState: " + IntToHexString(nAmbientState) + ")");
        return;
    }    
    
    // Check if creature already doing or about to do something.
    if (GetCommandType(GetCurrentCommand(oCreature)) != COMMAND_TYPE_INVALID || GetCommandQueueSize(oCreature) &gt; 0)
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoSomething()", "Busy - command(s) in queue: " + Log_GetCommandNameById(GetCommandType(GetCurrentCommand(oCreature))));
        return;
    }    
                                                    
    // The AMBIENT_SYSTEM_ALWAYSON flag skips timer and combat checks (ergo, use it sparingly).
    if (!(nAmbientState &amp; AMBIENT_SYSTEM_ALWAYSON)) 
    {               
        // Check whether creature or player is in combat
        if (GetGameMode() == GM_COMBAT || GetCombatState(oCreature))       
        {
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoSomething()", "Busy - in combat");
            return;
        }       
        
        // Check whether ambient behaviour should start/continue or time out.
        if (Ambient_TimerExpired(oCreature, bUpdateTimer))
            return;        
    }

    if (Ambient_DoCommand(oCreature))
        return;

//    if (GetGroupId(oCreature) == GROUP_HOSTILE)
//        return;

    if (Ambient_ReachedDestination(oCreature))
    {
        // Play animations if in an animation phase, otherwise attempt a movement phase.
        if (GetLocalInt(oCreature, AMBIENT_ANIM_STATE) != AMBIENT_ANIM_NONE)
            Ambient_Animate(oCreature);
        else
            Ambient_Move(oCreature);
    }
    else
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoSomething()", "Do nothing");
    }
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Returns TRUE if a creature's ambient behaviour has been overridden.
*
*   @param oCreature       The creature in question.
**//////////////////////////////////////////////////////////////////////////////
int Ambient_IsBehaviourOverridden(object oCreature = OBJECT_SELF)
{
    return (GetLocalInt(oCreature , AMBIENT_ANIM_OVERRIDE_COUNT) != 0);
}

////////////////////////////////////////////////////////////////////////////////
/** @brief Overrides a creature's predefined ambient behaviour.
*
*   Overrides the ambient behaviour animation pattern and animation frequency
*   defined by the creature template. -1.0 to play all animations in order)
*
*   @param oCreature       The creature performing the ambient behaviour.
*   @param nAnimPattern    The override animation pattern (index into ambient_ai.xls).
*   @param fAnimFreq       The override animation frequency (see description).
*   @param nOverrideCount  The number of times the override animation pattern is to be played (-1 for infinite).
**//////////////////////////////////////////////////////////////////////////////
void Ambient_OverrideBehaviour(object oCreature, int nAnimPattern, float fAnimFreq, int nOverrideCount)
{
    if (GetObjectType(oCreature) != OBJECT_TYPE_CREATURE
        || !GetObjectActive(oCreature) || IsDead(oCreature) || IsPartyMember(oCreature)
        || GetGroupId(oCreature) == GROUP_HOSTILE)
        return;


    int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);

    if (nAmbientState &amp; AMBIENT_SYSTEM_ENABLED)
    {
        Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_OverrideBehaviour()", "nAnimPattern: " + ToString(nAnimPattern) + ", fAnimFreq: " + ToString(fAnimFreq) + ", nOverrideCount: " + ToString(nOverrideCount));

        SetLocalInt(oCreature, AMBIENT_ANIM_PATTERN_OVERRIDE, nAnimPattern);
        SetLocalFloat(oCreature, AMBIENT_ANIM_FREQ_OVERRIDE, fAnimFreq);
        SetLocalInt(oCreature, AMBIENT_ANIM_STATE, AMBIENT_ANIM_RESET);
        SetLocalInt(oCreature, AMBIENT_ANIM_OVERRIDE_COUNT, nOverrideCount);

        SignalEvent(oCreature, Event(EVENT_TYPE_AMBIENT_CONTINUE));
    }
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Restores a creature's ambient animation behaviour to that defined in the creature's template.
*
*   @param oCreature  The creature whose ambient animation behaviour to restore.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_RestoreBehaviour(object oCreature)
{
    Ambient_OverrideBehaviour(oCreature, AMBIENT_ANIM_PATTERN_NONE, AMBIENT_ANIM_FREQ_NONE, 0);
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Forces a creature to repeatedly attack an object.
*
*   @param oAttacker    The attacking creature.
*   @param fDelay       Delay to wait (in seconds) before attacking again.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_DoCommandAttack(object oAttacker, float fDelay)
{
    event ev = GetCurrentEvent();
    switch (GetEventType(ev))
    {
        // Ambient_DoCommand() can be invoked by the event handler script of an
        // area or a creature. Hence the odd collection of events below.

        case EVENT_TYPE_AREALOAD_PRELOADEXIT:   // Invoked from area's event handler script.
        case EVENT_TYPE_AREALOAD_POSTLOADEXIT:  // Invoked from area's event handler script.
        case EVENT_TYPE_SPAWN:                  // Invoked from creature's event handler script.
        case EVENT_TYPE_OBJECT_ACTIVE:          // Invoked from creature's event handler script.
        case EVENT_TYPE_AMBIENT_CONTINUE:       // Invoked from creature's event handler script.
        {
            Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoCommandAttack()", "Kickstarting " + ToString(oAttacker));

            WR_AddCommand(oAttacker, CommandWait(fDelay));
            break;
        }

        case EVENT_TYPE_COMMAND_COMPLETE:       // Invoked from creature's event handler script.
        {
            switch (GetEventInteger(ev, 0))
            {
                case COMMAND_TYPE_WAIT:
                {
                    // Attack target if player is wandering around. Otherwise, wait a bit.
                    // Expected attacker tag format: XXXcr_XXX.
                    // Expected target tag format:   XXXip_XXX_target.
                    switch (GetGameMode())
                    {
                        case GM_EXPLORE:
                        case GM_FIXED:
                        case GM_FLYCAM:
                        {
                            string sTargetTag = ReplaceString(GetTag(oAttacker), "cr_", "ip_") + "_target";
                            object[] aTarget  = GetNearestObjectByTag(oAttacker, sTargetTag);

                            if (GetArraySize(aTarget) == 0)
                                aTarget = GetNearestObjectByTag(oAttacker, GetTag(oAttacker) + "_target");

                            if (GetArraySize(aTarget) &gt; 0)
                            {
                                if (IsDead(aTarget[0]))
                                    Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoCommandAttack()", "WARNING: Target is dead - " + ToString(aTarget[0]));

                                // Only shoot if player isn't in the way.
                                float fAngleToPlayer = GetAngleBetweenObjects(oAttacker, GetMainControlled());
                                if ((fAngleToPlayer &lt; 20.0 || fAngleToPlayer &gt; 340.0) &amp;&amp; GetDistanceBetween(oAttacker, GetMainControlled()) &lt; GetDistanceBetween(oAttacker, aTarget[0]))
                                    WR_AddCommand(oAttacker, CommandWait(4.0f));
                                else
                                    WR_AddCommand(oAttacker, CommandAttack(aTarget[0]));
                            }
                            else
                            {
                                Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoCommandAttack()", "Failed to find valid target");
                            }
                            break;
                        }
                        default:
                        {
                            // Wait a bit till combat or conversation ends.
                            WR_AddCommand(oAttacker, CommandWait(6.0f));
                        }
                    }
                    break;
                }
                case COMMAND_TYPE_ATTACK:
                {
                    Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoCommandAttack()", "Wait.");

                    // Wait a bit before attacking again.
                    WR_AddCommand(oAttacker, CommandWait(fDelay));
                    break;
                }
            }
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Triggers ambient commands.
*
*   @param oCreature  The creature to assign an ambient command.
*   @param nCommand   The command to perform (AMBIENT_COMMAND_***). If zero, uses the AMBIENT_COMMAND local integer set on oCreature.
*   @returns          TRUE if oCreature has an ambient command to perform. FALSE otherwise.
**//////////////////////////////////////////////////////////////////////////////
int Ambient_DoCommand(object oCreature = OBJECT_SELF, int nCommand = 0)
{
    if (nCommand == 0)
    {
        nCommand = GetLocalInt(oCreature, AMBIENT_COMMAND);
    }
    else
    {
        SetLocalInt(oCreature, AMBIENT_COMMAND, nCommand);

        // Hack: Originally AMBIENT_COMMAND didn't require the AMBIENT_SYSTEM_ENABLED bit set. Now it does, so flip the bit here.
        int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);
        SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState | AMBIENT_SYSTEM_ENABLED);
    }

    if (nCommand)
    {
        switch (nCommand)
        {
            case AMBIENT_COMMAND_ATTACK_PRACTISE:
                Ambient_DoCommandAttack(oCreature, RandomFloat() * 5.0f);
                break;
            case AMBIENT_COMMAND_ATTACK:
                Ambient_DoCommandAttack(oCreature, 0.05f);
                break;
            default:
                Log_Trace(LOG_CHANNEL_AMBIENT_AI, "Ambient_DoCommand()", "Unhandled AMBIENT_COMMAND value.");
                break;
        }
    }
    return nCommand;
}


////////////////////////////////////////////////////////////////////////////////
/** @brief Called from event handler for EVENT_TYPE_COMMAND_COMPLETE
*
*   @param nCommandType   The type of the command that completed.
*   @param nCommandStatus The status of the command that completed.
*   @param oCreature      The creature that completed the command.
**//////////////////////////////////////////////////////////////////////////////
void Ambient_CommandComplete(int nCommandType, int nCommandStatus, object oCreature = OBJECT_SELF)
{
    if (IsPartyMember(oCreature) || GetCombatState(oCreature))
        return;

    if (nCommandType == COMMAND_TYPE_INTERACT || nCommandType == COMMAND_TYPE_PLAY_ANIMATION)
    {
        if (nCommandStatus == COMMAND_LOOPING)
            return;
        if (nCommandStatus == COMMAND_SUCCESSFUL)
        {
            int nAmbientState = GetLocalInt(oCreature, AMBIENT_SYSTEM_STATE);
            SetLocalInt(oCreature, AMBIENT_SYSTEM_STATE, nAmbientState &amp; ~AMBIENT_SYSTEM_RUNNING);
        }
    }

    Ambient_DoSomething();
}</text>
	</Agent>
</Resource>